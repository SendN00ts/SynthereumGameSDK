"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var index_exports = {};
__export(index_exports, {
  GameTwitterClient: () => GameTwitterClient,
  TwitterClient: () => TwitterClient,
  default: () => index_default
});
module.exports = __toCommonJS(index_exports);

// src/twitterPlugin.ts
var import_game = require("@virtuals-protocol/game");
var TwitterPlugin = class {
  constructor(options) {
    this.id = options.id || "twitter_worker";
    this.name = options.name || "Twitter Worker";
    this.description = options.description || "A worker that will execute tasks within the Twitter Social Platforms. It is capable of posting, reply, quote and like tweets.";
    this.twitterClient = options.twitterClient;
  }
  getWorker(data) {
    return new import_game.GameWorker({
      id: this.id,
      name: this.name,
      description: this.description,
      functions: (data == null ? void 0 : data.functions) || [
        this.searchTweetsFunction,
        this.replyTweetFunction,
        this.postTweetFunction,
        this.likeTweetFunction,
        this.quoteTweetFunction
      ],
      getEnvironment: (data == null ? void 0 : data.getEnvironment) || this.getMetrics.bind(this)
    });
  }
  getMetrics() {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f;
      const result = yield this.twitterClient.me();
      return {
        followers: (_b = (_a = result.data.public_metrics) == null ? void 0 : _a.followers_count) != null ? _b : 0,
        following: (_d = (_c = result.data.public_metrics) == null ? void 0 : _c.following_count) != null ? _d : 0,
        tweets: (_f = (_e = result.data.public_metrics) == null ? void 0 : _e.tweet_count) != null ? _f : 0
      };
    });
  }
  get searchTweetsFunction() {
    return new import_game.GameFunction({
      name: "search_tweets",
      description: "Search tweets",
      args: [{ name: "query", description: "The search query" }],
      executable: (args, logger) => __async(this, null, function* () {
        try {
          if (!args.query) {
            return new import_game.ExecutableGameFunctionResponse(
              import_game.ExecutableGameFunctionStatus.Failed,
              "Query is required"
            );
          }
          logger(`Searching for: ${args.query}`);
          const tweets = yield this.twitterClient.search(args.query);
          const feedbackMessage = "Tweets found:\n" + JSON.stringify(
            tweets.data.map((tweet) => {
              var _a, _b, _c;
              return {
                tweetId: tweet.id,
                content: tweet.text,
                likes: (_a = tweet.public_metrics) == null ? void 0 : _a.like_count,
                retweets: (_b = tweet.public_metrics) == null ? void 0 : _b.retweet_count,
                replyCount: (_c = tweet.public_metrics) == null ? void 0 : _c.reply_count
              };
            })
          );
          logger(feedbackMessage);
          return new import_game.ExecutableGameFunctionResponse(
            import_game.ExecutableGameFunctionStatus.Done,
            feedbackMessage
          );
        } catch (e) {
          return new import_game.ExecutableGameFunctionResponse(
            import_game.ExecutableGameFunctionStatus.Failed,
            "Failed to search tweets"
          );
        }
      })
    });
  }
  get replyTweetFunction() {
    return new import_game.GameFunction({
      name: "reply_tweet",
      description: "Reply to a tweet where your think is the most interesting",
      args: [
        { name: "tweet_id", description: "The tweet id" },
        { name: "reply", description: "The reply content" },
        {
          name: "reply_reasoning",
          description: "The reasoning behind the reply"
        }
      ],
      executable: (args, logger) => __async(this, null, function* () {
        try {
          if (!args.tweet_id || !args.reply) {
            return new import_game.ExecutableGameFunctionResponse(
              import_game.ExecutableGameFunctionStatus.Failed,
              "Tweet id and reply content are required"
            );
          }
          logger(`Replying [${args.tweet_id}]: ${args.reply}`);
          yield this.twitterClient.reply(args.tweet_id, args.reply);
          return new import_game.ExecutableGameFunctionResponse(
            import_game.ExecutableGameFunctionStatus.Done,
            "Replied to tweet"
          );
        } catch (e) {
          return new import_game.ExecutableGameFunctionResponse(
            import_game.ExecutableGameFunctionStatus.Failed,
            "Failed to reply to tweet"
          );
        }
      })
    });
  }
  get postTweetFunction() {
    return new import_game.GameFunction({
      name: "post_tweet",
      description: "Post a tweet",
      args: [
        { name: "tweet", description: "The tweet content" },
        {
          name: "tweet_reasoning",
          description: "The reasoning behind the tweet"
        }
      ],
      executable: (args, logger) => __async(this, null, function* () {
        try {
          if (!args.tweet) {
            return new import_game.ExecutableGameFunctionResponse(
              import_game.ExecutableGameFunctionStatus.Failed,
              "Tweet content is required"
            );
          }
          logger(`Posting tweet: ${args.tweet}`);
          yield this.twitterClient.post(args.tweet);
          return new import_game.ExecutableGameFunctionResponse(
            import_game.ExecutableGameFunctionStatus.Done,
            "Tweet posted"
          );
        } catch (e) {
          return new import_game.ExecutableGameFunctionResponse(
            import_game.ExecutableGameFunctionStatus.Failed,
            "Failed to post tweet"
          );
        }
      })
    });
  }
  get likeTweetFunction() {
    return new import_game.GameFunction({
      name: "like_tweet",
      description: "Like a tweet. Choose this when you want to support a tweet quickly, without needing to comment.",
      args: [{ name: "tweet_id", description: "The tweet id" }],
      executable: (args, logger) => __async(this, null, function* () {
        try {
          if (!args.tweet_id) {
            return new import_game.ExecutableGameFunctionResponse(
              import_game.ExecutableGameFunctionStatus.Failed,
              "Tweet id is required"
            );
          }
          logger(`Liking tweet id: ${args.tweet_id}`);
          yield this.twitterClient.like(args.tweet_id);
          return new import_game.ExecutableGameFunctionResponse(
            import_game.ExecutableGameFunctionStatus.Done,
            "Tweet liked"
          );
        } catch (e) {
          return new import_game.ExecutableGameFunctionResponse(
            import_game.ExecutableGameFunctionStatus.Failed,
            "Failed to like tweet"
          );
        }
      })
    });
  }
  get quoteTweetFunction() {
    return new import_game.GameFunction({
      name: "quote_tweet",
      description: "Share someone else\u2019s tweet while adding your own commentary. Use this when you want to provide your opinion, analysis, or humor on an existing tweet while still promoting the original content. This will help with your social presence.",
      args: [
        { name: "tweet_id", description: "The tweet id" },
        { name: "quote", description: "The quote content" }
      ],
      executable: (args, logger) => __async(this, null, function* () {
        try {
          if (!args.tweet_id || !args.quote) {
            return new import_game.ExecutableGameFunctionResponse(
              import_game.ExecutableGameFunctionStatus.Failed,
              "Tweet id and quote content are required"
            );
          }
          logger(`Quoting [${args.tweet_id}]: ${args.quote}`);
          yield this.twitterClient.quote(args.tweet_id, args.quote);
          return new import_game.ExecutableGameFunctionResponse(
            import_game.ExecutableGameFunctionStatus.Done,
            "Tweet quoted"
          );
        } catch (e) {
          return new import_game.ExecutableGameFunctionResponse(
            import_game.ExecutableGameFunctionStatus.Failed,
            "Failed to quote tweet"
          );
        }
      })
    });
  }
};
var twitterPlugin_default = TwitterPlugin;

// src/twitterClient.ts
var import_twitter_api_v2 = __toESM(require("twitter-api-v2"));
var TwitterClient = class {
  constructor(credential) {
    this.twitterClient = new import_twitter_api_v2.default({
      appKey: credential.apiKey,
      appSecret: credential.apiSecretKey,
      accessToken: credential.accessToken,
      accessSecret: credential.accessTokenSecret
    });
  }
  get client() {
    return this.twitterClient;
  }
  post(tweet) {
    return this.twitterClient.v2.tweet(tweet);
  }
  search(query) {
    return __async(this, null, function* () {
      const response = yield this.twitterClient.v2.search(query, {
        max_results: 10,
        "tweet.fields": ["public_metrics"]
      });
      return response.data;
    });
  }
  reply(tweetId, reply) {
    return this.twitterClient.v2.reply(reply, tweetId);
  }
  like(tweetId) {
    return __async(this, null, function* () {
      const me = yield this.twitterClient.v2.me();
      return this.twitterClient.v2.like(me.data.id, tweetId);
    });
  }
  quote(tweetId, quote) {
    return this.twitterClient.v2.quote(quote, tweetId);
  }
  me() {
    return this.twitterClient.v2.me({
      "user.fields": ["public_metrics"]
    });
  }
  mentions(paginationToken) {
    return __async(this, null, function* () {
      const me = yield this.twitterClient.v2.me();
      const options = {};
      if (paginationToken) {
        options.pagination_token = paginationToken;
      }
      const response = yield this.twitterClient.v2.userMentionTimeline(
        me.data.id,
        options
      );
      return response.data;
    });
  }
  followers(paginationToken) {
    return __async(this, null, function* () {
      const me = yield this.twitterClient.v2.me();
      const options = {};
      if (paginationToken) {
        options.pagination_token = paginationToken;
      }
      const response = yield this.twitterClient.v2.followers(me.data.id, options);
      return response;
    });
  }
  following(paginationToken) {
    return __async(this, null, function* () {
      const me = yield this.twitterClient.v2.me();
      const options = {};
      if (paginationToken) {
        options.pagination_token = paginationToken;
      }
      const response = yield this.twitterClient.v2.following(me.data.id, options);
      return response;
    });
  }
  uploadMedia(media) {
    return __async(this, null, function* () {
      const mediaBuffer = Buffer.from(yield media.arrayBuffer());
      const response = yield this.twitterClient.v2.uploadMedia(mediaBuffer, {
        media_type: media.type
      });
      return response;
    });
  }
};

// src/gameTwitterClient.ts
var GameTwitterClient = class {
  constructor(credential) {
    this.baseURL = "https://twitter.game.virtuals.io/tweets";
    this.headers = {
      "x-api-key": `${credential.accessToken}`
    };
  }
  fetchAPI(endpoint, options) {
    return __async(this, null, function* () {
      const response = yield fetch(`${this.baseURL}${endpoint}`, __spreadProps(__spreadValues({}, options), {
        headers: __spreadValues({
          "Content-Type": "application/json"
        }, this.headers)
      }));
      if (!response.ok) {
        throw new Error(`Error: ${response.statusText}`);
      }
      return response.json();
    });
  }
  fetchFormData(endpoint, options) {
    return __async(this, null, function* () {
      const response = yield fetch(`${this.baseURL}${endpoint}`, __spreadProps(__spreadValues({}, options), {
        headers: this.headers
      }));
      if (!response.ok) {
        throw new Error(`Error: ${response.statusText}`);
      }
      return response.json();
    });
  }
  post(tweet, mediaIds) {
    return __async(this, null, function* () {
      return this.fetchAPI("/post", {
        method: "POST",
        body: JSON.stringify({ content: tweet, mediaIds })
      });
    });
  }
  search(query) {
    return __async(this, null, function* () {
      return this.fetchAPI(
        `/search?query=${encodeURIComponent(query)}`,
        {
          method: "GET"
        }
      );
    });
  }
  reply(tweetId, reply, mediaIds) {
    return __async(this, null, function* () {
      return this.fetchAPI(`/reply/${tweetId}`, {
        method: "POST",
        body: JSON.stringify({ content: reply, mediaIds })
      });
    });
  }
  like(tweetId) {
    return __async(this, null, function* () {
      return this.fetchAPI(`/like/${tweetId}`, {
        method: "POST"
      });
    });
  }
  quote(tweetId, quote) {
    return __async(this, null, function* () {
      return this.fetchAPI(`/quote/${tweetId}`, {
        method: "POST",
        body: JSON.stringify({ content: quote })
      });
    });
  }
  me() {
    return __async(this, null, function* () {
      return this.fetchAPI("/me", {
        method: "GET"
      });
    });
  }
  mentions(paginationToken) {
    return __async(this, null, function* () {
      let url = "/mentions";
      if (paginationToken) {
        url += `?paginationToken=${paginationToken}`;
      }
      return this.fetchAPI(url, {
        method: "GET"
      });
    });
  }
  followers(paginationToken) {
    return __async(this, null, function* () {
      let url = "/followers";
      if (paginationToken) {
        url += `?paginationToken=${paginationToken}`;
      }
      return this.fetchAPI(url, {
        method: "GET"
      });
    });
  }
  following(paginationToken) {
    return __async(this, null, function* () {
      let url = "/following";
      if (paginationToken) {
        url += `?paginationToken=${paginationToken}`;
      }
      return this.fetchAPI(url, {
        method: "GET"
      });
    });
  }
  uploadMedia(media) {
    return __async(this, null, function* () {
      const formData = new FormData();
      formData.append("file", media);
      const result = yield this.fetchFormData(`/media`, {
        method: "POST",
        body: formData
      });
      return result.mediaId;
    });
  }
};

// src/index.ts
var index_default = twitterPlugin_default;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  GameTwitterClient,
  TwitterClient
});
